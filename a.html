<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>è¿·å®® + å…‰ç…§æ•ˆæœï¼ˆæœƒè¿·è·¯ç‰ˆï¼‰</title>

    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(180deg, #001f3f, #000000);
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            background: transparent;
            display: block;
            margin: 0 auto;
        }

        #success {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            color: white;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.8s ease;
            pointer-events: none;
            text-shadow: 0 0 20px white;
        }
        #success.show { opacity: 1; }

        .buttons {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .buttons button {
            padding: 10px 18px;
            font-size: 16px;
            border-radius: 8px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
        }
        .buttons button:hover { background: rgba(255,255,255,0.35); }
    </style>
</head>
<body>

<div class="buttons">
    <button onclick="setDifficulty('easy')">ç°¡å–®</button>
    <button onclick="setDifficulty('normal')">æ™®é€š</button>
    <button onclick="setDifficulty('hard')">å›°é›£</button>
</div>

<canvas id="mazeCanvas"></canvas>
<div id="success">æˆåŠŸ</div>

<script>
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");

let COLS = 30, ROWS = 20, CELL = 40;
let grid;

let player = { x: 0, y: 0, r: 6 };
let lightRadius = 200;
let finish = { x: 0, y: 0 };

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const successEl = document.getElementById("success");

function createGrid() {
    const g = [];
    for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
            row.push({ r, c, visited: false, walls: { top: true, right: true, bottom: true, left: true } });
        }
        g.push(row);
    }
    return g;
}

function generateMaze() {
    const stack = [];
    let current = grid[0][0];
    current.visited = true;

    while (true) {
        const n = [];
        const { r, c } = current;
        if (r > 0 && !grid[r-1][c].visited) n.push(grid[r-1][c]);
        if (c < COLS-1 && !grid[r][c+1].visited) n.push(grid[r][c+1]);
        if (r < ROWS-1 && !grid[r+1][c].visited) n.push(grid[r+1][c]);
        if (c > 0 && !grid[r][c-1].visited) n.push(grid[r][c-1]);

        if (n.length) {
            const next = n[Math.random()*n.length|0];
            if (next.r === r-1) { current.walls.top=false; next.walls.bottom=false; }
            if (next.c === c+1) { current.walls.right=false; next.walls.left=false; }
            if (next.r === r+1) { current.walls.bottom=false; next.walls.top=false; }
            if (next.c === c-1) { current.walls.left=false; next.walls.right=false; }
            stack.push(current);
            current = next;
            current.visited = true;
        } else if (stack.length) current = stack.pop();
        else break;
    }

    // ğŸ”¥ é—œéµï¼šéš¨æ©Ÿæ‰“ç ´ç‰†å£ï¼ˆè£½é€ ã€Œç’°ã€ï¼‰
    const breakRate = 0.08; // 8% ç‰†æœƒè¢«æ‰“ç ´
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (Math.random() < breakRate) {
                const cell = grid[r][c];
                const dirs = ['top','right','bottom','left'];
                const d = dirs[Math.random()*4|0];
                if (d==='top' && r>0) { cell.walls.top=false; grid[r-1][c].walls.bottom=false; }
                if (d==='right' && c<COLS-1) { cell.walls.right=false; grid[r][c+1].walls.left=false; }
                if (d==='bottom' && r<ROWS-1) { cell.walls.bottom=false; grid[r+1][c].walls.top=false; }
                if (d==='left' && c>0) { cell.walls.left=false; grid[r][c-1].walls.right=false; }
            }
        }
    }
}

function drawMazeTo(c) {
    c.strokeStyle = '#fff';
    c.lineWidth = 3;
    for (let r=0;r<ROWS;r++) for (let c2=0;c2<COLS;c2++) {
        const cell = grid[r][c2];
        const x=c2*CELL, y=r*CELL;
        c.beginPath();
        if(cell.walls.top) c.moveTo(x,y),c.lineTo(x+CELL,y);
        if(cell.walls.right) c.moveTo(x+CELL,y),c.lineTo(x+CELL,y+CELL);
        if(cell.walls.bottom) c.moveTo(x,y+CELL),c.lineTo(x+CELL,y+CELL);
        if(cell.walls.left) c.moveTo(x,y),c.lineTo(x,y+CELL);
        c.stroke();
    }

    // èµ·é»
    c.fillStyle='lime';
    c.beginPath(); c.arc(CELL/2,CELL/2,8,0,Math.PI*2); c.fill();

    // çµ‚é»
    c.fillStyle='red';
    c.beginPath(); c.arc(finish.x,finish.y,8,0,Math.PI*2); c.fill();
}

function drawLighting() {
    const off=document.createElement('canvas');
    off.width=canvas.width; off.height=canvas.height;
    const o=off.getContext('2d');

    drawMazeTo(o);

    const g=o.createRadialGradient(player.x,player.y,0,player.x,player.y,lightRadius);
    g.addColorStop(0,'rgba(255,255,255,1)');
    g.addColorStop(1,'rgba(255,255,255,0)');

    o.globalCompositeOperation='destination-in';
    o.fillStyle=g;
    o.fillRect(0,0,off.width,off.height);

    ctx.drawImage(off,0,0);

    // äººç‰©
    ctx.fillStyle='white';
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
}

function cellAt(x,y){
    return grid[Math.floor(y/CELL)]?.[Math.floor(x/CELL)];
}

function canMove(nx, ny) {
    const r = player.r + 1;

    // ä»¥ã€Œç›®æ¨™ä½ç½®ã€åˆ¤æ–·æ‰€åœ¨æ ¼å­ï¼Œé¿å…å¡ç‰†
    const cx = Math.floor(nx / CELL);
    const cy = Math.floor(ny / CELL);
    const cell = grid[cy]?.[cx];
    if (!cell) return false;

    const left   = cx * CELL;
    const right  = (cx + 1) * CELL;
    const top    = cy * CELL;
    const bottom = (cy + 1) * CELL;

    // å³ç‰†
    if (cell.walls.right && nx + r > right) return false;
    // å·¦ç‰†
    if (cell.walls.left && nx - r < left) return false;
    // ä¸‹ç‰†
    if (cell.walls.bottom && ny + r > bottom) return false;
    // ä¸Šç‰†
    if (cell.walls.top && ny - r < top) return false;

    return true;
}

window.addEventListener('keydown', e => {
    const speed = 4;
    let nx = player.x;
    let ny = player.y;

    if (e.key === 'ArrowLeft') nx -= speed;
    if (e.key === 'ArrowRight') nx += speed;
    if (e.key === 'ArrowUp') ny -= speed;
    if (e.key === 'ArrowDown') ny += speed;

    // åˆ†é–‹æª¢æŸ¥ X / Yï¼Œé¿å…å¡æ­»åœ¨ç‰†è§’
    if (canMove(nx, player.y)) player.x = nx;
    if (canMove(player.x, ny)) player.y = ny;
});

function checkGoal(){
    if(Math.hypot(player.x-finish.x,player.y-finish.y)<10)
        successEl.classList.add('show');
}

function rebuild(){
    grid=createGrid();
    generateMaze();
    player.x=CELL/2; player.y=CELL/2;
    finish.x=(COLS-1)*CELL+CELL/2;
    finish.y=(ROWS-1)*CELL+CELL/2;
    canvas.width=COLS*CELL;
    canvas.height=ROWS*CELL;
    successEl.classList.remove('show');
}

function setDifficulty(l){
    if(l==='easy'){COLS=18;ROWS=12;CELL=50;}
    if(l==='normal'){COLS=30;ROWS=20;CELL=40;}
    if(l==='hard'){COLS=45;ROWS=30;CELL=30;}
    rebuild();
}

rebuild();

(function loop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawLighting();
    checkGoal();
    requestAnimationFrame(loop);
})();
</script>
</body>
</html>
