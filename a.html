<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>迷宮 + 光照效果</title>

<style>
body {
    margin: 0;
    padding: 0;
    background: linear-gradient(180deg, #001f3f, #000000);
    height: 100vh;
    overflow: hidden;
}

canvas {
    background: transparent;
    display: block;
    margin: 0 auto;
}

#success {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 60px;
    color: white;
    font-weight: bold;
    opacity: 0;
    transition: opacity 0.8s ease;
    pointer-events: none;
    text-shadow: 0 0 20px white;
}

#success.show { opacity: 1; }

.buttons {
    position: fixed;
    top: 20px;
    left: 20px;
    display: flex;
    gap: 10px;
}

.buttons button {
    padding: 10px 20px;
    font-size: 18px;
    border: none;
    border-radius: 8px;
    background: rgba(255,255,255,0.2);
    color: white;
    cursor: pointer;
    backdrop-filter: blur(4px);
}
</style>
</head>

<body>

<div class="buttons">
    <button onclick="setDifficulty('easy')">簡單</button>
    <button onclick="setDifficulty('normal')">普通</button>
    <button onclick="setDifficulty('hard')">困難</button>
</div>

<canvas id="mazeCanvas"></canvas>
<div id="success">成功</div>

<script>
// ================= Canvas =================
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");

// 迷宮尺寸
let COLS = 30, ROWS = 20, CELL = 40;

// 光圈 & 人物
let player = { x: 0, y: 0, r: 8 };
let lightRadius = 200;
const speed = 4;

// 起點終點
let startX, startY, finishX, finishY;

// 迷宮資料
let grid = [];

// 成功顯示
const successEl = document.getElementById("success");

// ================= 建立迷宮 =================
function createGrid(){
    const g=[];
    for(let r=0;r<ROWS;r++){
        const row=[];
        for(let c=0;c<COLS;c++){
            row.push({
                r,c,visited:false,
                walls:{top:true,right:true,bottom:true,left:true}
            });
        }
        g.push(row);
    }
    return g;
}

function generateMaze(){
    const stack=[];
    let current = grid[0][0];
    current.visited=true;

    while(true){
        const n=[];
        const {r,c}=current;
        if(r>0&&!grid[r-1][c].visited) n.push(grid[r-1][c]);
        if(c<COLS-1&&!grid[r][c+1].visited) n.push(grid[r][c+1]);
        if(r<ROWS-1&&!grid[r+1][c].visited) n.push(grid[r+1][c]);
        if(c>0&&!grid[r][c-1].visited) n.push(grid[r][c-1]);

        if(n.length){
            const next=n[Math.random()*n.length|0];
            if(next.r===r-1){current.walls.top=false;next.walls.bottom=false;}
            if(next.c===c+1){current.walls.right=false;next.walls.left=false;}
            if(next.r===r+1){current.walls.bottom=false;next.walls.top=false;}
            if(next.c===c-1){current.walls.left=false;next.walls.right=false;}
            stack.push(current);
            current=next;
            current.visited=true;
        }else if(stack.length) current=stack.pop();
        else break;
    }
}

// ================= 繪製迷宮 =================
function drawMazeTo(c){
    c.strokeStyle="#ffffff";
    c.lineWidth=3;

    for(let r=0;r<ROWS;r++){
        for(let c2=0;c2<COLS;c2++){
            const cell=grid[r][c2];
            const x=c2*CELL,y=r*CELL;
            c.beginPath();
            if(cell.walls.top) c.moveTo(x,y),c.lineTo(x+CELL,y);
            if(cell.walls.right) c.moveTo(x+CELL,y),c.lineTo(x+CELL,y+CELL);
            if(cell.walls.bottom) c.moveTo(x,y+CELL),c.lineTo(x+CELL,y+CELL);
            if(cell.walls.left) c.moveTo(x,y),c.lineTo(x,y+CELL);
            c.stroke();
        }
    }

    // 起點
    c.fillStyle="rgba(0,255,0,0.9)";
    c.beginPath();
    c.arc(startX,startY,CELL*0.25,0,Math.PI*2);
    c.fill();

    // 終點
    c.fillStyle="rgba(255,0,0,0.9)";
    c.beginPath();
    c.arc(finishX,finishY,CELL*0.3,0,Math.PI*2);
    c.fill();
}

// ================= 光照 =================
function drawLighting(){
    const off=document.createElement("canvas");
    off.width=canvas.width;
    off.height=canvas.height;
    const o=off.getContext("2d");

    drawMazeTo(o);

    // 人物
    o.fillStyle="white";
    o.beginPath();
    o.arc(player.x,player.y,player.r,0,Math.PI*2);
    o.fill();

    const g=o.createRadialGradient(player.x,player.y,0,player.x,player.y,lightRadius);
    g.addColorStop(0,"rgba(255,255,255,1)");
    g.addColorStop(1,"rgba(255,255,255,0)");

    o.globalCompositeOperation="destination-in";
    o.fillStyle=g;
    o.fillRect(0,0,off.width,off.height);

    ctx.drawImage(off,0,0);
}

// ================= 碰撞判定 =================
function canMove(nx,ny){
    const c = Math.floor(nx / CELL);
    const r = Math.floor(ny / CELL);
    if(r<0||c<0||r>=ROWS||c>=COLS) return false;
    return true;
}

// ================= 鍵盤控制 =================
document.addEventListener("keydown",e=>{
    let nx=player.x, ny=player.y;
    if(e.key==="ArrowUp") ny-=speed;
    if(e.key==="ArrowDown") ny+=speed;
    if(e.key==="ArrowLeft") nx-=speed;
    if(e.key==="ArrowRight") nx+=speed;
    if(canMove(nx,ny)){
        player.x=nx;
        player.y=ny;
    }
});

// ================= 目標 =================
function checkGoal(){
    if(Math.hypot(player.x-finishX,player.y-finishY)<CELL*0.4){
        successEl.classList.add("show");
    }
}

// ================= 重建 =================
function rebuildMaze(){
    grid=createGrid();
    generateMaze();

    canvas.width = COLS*CELL;
    canvas.height = ROWS*CELL;

    startX=CELL/2; startY=CELL/2;
    finishX=(COLS-1)*CELL+CELL/2;
    finishY=(ROWS-1)*CELL+CELL/2;

    player.x=startX; player.y=startY;
    successEl.classList.remove("show");
}

// ================= 難度 =================
function setDifficulty(l){
    if(l==="easy"){COLS=20;ROWS=14;CELL=50;}
    if(l==="normal"){COLS=30;ROWS=20;CELL=40;}
    if(l==="hard"){COLS=45;ROWS=30;CELL=30;}
    rebuildMaze();
}

setDifficulty("normal");

// ================= 主迴圈 =================
function loop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawLighting();
    checkGoal();
    requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
