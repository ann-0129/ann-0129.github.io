<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>迷宮・光照探索</title>

<style>
body{
    margin:0;
    overflow:hidden;
    background:linear-gradient(180deg,#001f3f,#000000);
}
canvas{
    display:block;
    margin:0 auto;
    background:transparent;
}
#success{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    font-size:60px;
    font-weight:bold;
    color:white;
    opacity:0;
    transition:0.8s;
    pointer-events:none;
    text-shadow:0 0 20px white;
}
#success.show{opacity:1;}
</style>
</head>

<body>
<canvas id="mazeCanvas"></canvas>
<div id="success">成功</div>

<script>
// ================= 基本設定 =================
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

const COLS = 30;
const ROWS = 20;
const CELL = 40;

let lightX = CELL / 2;
let lightY = CELL / 2;
const lightRadius = 200;

const start = { x: CELL/2, y: CELL/2 };
const end   = { x:(COLS-1)*CELL + CELL/2, y:(ROWS-1)*CELL + CELL/2 };

const successEl = document.getElementById("success");

// ================= 建立迷宮 =================
function createGrid(){
    const g=[];
    for(let r=0;r<ROWS;r++){
        const row=[];
        for(let c=0;c<COLS;c++){
            row.push({
                r,c,visited:false,
                walls:{top:true,right:true,bottom:true,left:true}
            });
        }
        g.push(row);
    }
    return g;
}

let grid = createGrid();

function generateMaze(){
    const stack=[];
    let current = grid[0][0];
    current.visited=true;

    while(true){
        const n=[];
        const {r,c}=current;
        if(r>0&&!grid[r-1][c].visited) n.push(grid[r-1][c]);
        if(c<COLS-1&&!grid[r][c+1].visited) n.push(grid[r][c+1]);
        if(r<ROWS-1&&!grid[r+1][c].visited) n.push(grid[r+1][c]);
        if(c>0&&!grid[r][c-1].visited) n.push(grid[r][c-1]);

        if(n.length){
            const next=n[Math.random()*n.length|0];
            if(next.r===r-1){current.walls.top=false;next.walls.bottom=false;}
            if(next.c===c+1){current.walls.right=false;next.walls.left=false;}
            if(next.r===r+1){current.walls.bottom=false;next.walls.top=false;}
            if(next.c===c-1){current.walls.left=false;next.walls.right=false;}
            stack.push(current);
            current=next;
            current.visited=true;
        }else if(stack.length) current=stack.pop();
        else break;
    }

    // 光源回到起點
    lightX = start.x;
    lightY = start.y;
}

generateMaze();

// ================= 畫迷宮線 =================
function drawMazeTo(c){
    c.strokeStyle="#ffffff";
    c.lineWidth=3;

    for(let r=0;r<ROWS;r++){
        for(let c2=0;c2<COLS;c2++){
            const cell=grid[r][c2];
            const x=c2*CELL,y=r*CELL;
            c.beginPath();
            if(cell.walls.top) c.moveTo(x,y),c.lineTo(x+CELL,y);
            if(cell.walls.right) c.moveTo(x+CELL,y),c.lineTo(x+CELL,y+CELL);
            if(cell.walls.bottom) c.moveTo(x,y+CELL),c.lineTo(x+CELL,y+CELL);
            if(cell.walls.left) c.moveTo(x,y),c.lineTo(x,y+CELL);
            c.stroke();
        }
    }
}

// ================= 光照 + 迷宮 =================
function drawLighting(){
    const off=document.createElement("canvas");
    off.width=canvas.width;
    off.height=canvas.height;
    const o=off.getContext("2d");

    drawMazeTo(o);

    // 起點
    o.fillStyle="white";
    o.beginPath();
    o.arc(start.x,start.y,6,0,Math.PI*2);
    o.fill();

    // 終點脈動
    const t=Date.now()/600;
    o.strokeStyle="rgba(255,255,255,0.9)";
    o.lineWidth=2;
    o.beginPath();
    o.arc(end.x,end.y,10+Math.sin(t)*4,0,Math.PI*2);
    o.stroke();

    // 光圈遮罩
    const g=o.createRadialGradient(lightX,lightY,0,lightX,lightY,lightRadius);
    g.addColorStop(0,"rgba(255,255,255,1)");
    g.addColorStop(1,"rgba(255,255,255,0)");

    o.globalCompositeOperation="destination-in";
    o.fillStyle=g;
    o.fillRect(0,0,off.width,off.height);

    ctx.drawImage(off,0,0);
}

// ================= 主迴圈 =================
function loop(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawLighting();

    if(Math.hypot(lightX-end.x,lightY-end.y)<20){
        successEl.classList.add("show");
    }

    requestAnimationFrame(loop);
}
loop();

// ================= 滑鼠控制 =================
canvas.addEventListener("mousemove",e=>{
    const r=canvas.getBoundingClientRect();
    lightX=e.clientX-r.left;
    lightY=e.clientY-r.top;
});
</script>
</body>
</html>
