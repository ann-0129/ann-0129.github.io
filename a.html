<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8" />
    <title>迷宮 + 光照效果</title>
    <style>
       body {
    margin: 0;
    padding: 0;
    background: linear-gradient(180deg, #001f3f, #000000);
    height: 100vh;
}
        canvas {
    background: transparent;
    display: block;
    margin: 0 auto;
}
    </style>
</head>
<body>
<canvas id="mazeCanvas"></canvas>

<canvas id="mazeCanvas"></canvas>

<style>
    body {
        margin: 0;
        overflow: hidden;
        background: linear-gradient(180deg, #0B1732, #000000);
    }

    #success {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 60px;
        color: white;
        font-weight: bold;
        opacity: 0;
        transition: opacity 0.8s ease;
        pointer-events: none;
        text-shadow: 0 0 20px white;
    }

    #success.show {
        opacity: 1;
    }
</style>

<div id="success">成功</div>

<script>
// === Canvas ===
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const COLS = 30;
const ROWS = 20;
const CELL = 40;

let lightX = canvas.width / 2;
let lightY = canvas.height / 2;

const finishX = (COLS - 1) * CELL + CELL / 2;
const finishY = (ROWS - 1) * CELL + CELL / 2;

const successEl = document.getElementById("success");

// === 建立迷宮 ===
function createGrid() {
    const grid = [];
    for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
            row.push({
                r, c,
                walls: { top: true, right: true, bottom: true, left: true },
                visited: false
            });
        }
        grid.push(row);
    }
    return grid;
}

let grid = createGrid();

// === DFS 迷宮 ===
function generateMaze() {
    const stack = [];
    let current = grid[0][0];
    current.visited = true;

    while (true) {
        const neighbors = [];
        const { r, c } = current;

        if (r > 0 && !grid[r - 1][c].visited) neighbors.push(grid[r - 1][c]);
        if (c < COLS - 1 && !grid[r][c + 1].visited) neighbors.push(grid[r][c + 1]);
        if (r < ROWS - 1 && !grid[r + 1][c].visited) neighbors.push(grid[r + 1][c]);
        if (c > 0 && !grid[r][c - 1].visited) neighbors.push(grid[r][c - 1]);

        if (neighbors.length > 0) {
            const next = neighbors[Math.floor(Math.random() * neighbors.length)];

            if (next.r === r - 1) {
                current.walls.top = false;
                next.walls.bottom = false;
            } else if (next.c === c + 1) {
                current.walls.right = false;
                next.walls.left = false;
            } else if (next.r === r + 1) {
                current.walls.bottom = false;
                next.walls.top = false;
            } else if (next.c === c - 1) {
                current.walls.left = false;
                next.walls.right = false;
            }

            stack.push(current);
            current = next;
            current.visited = true;
        } else if (stack.length > 0) {
            current = stack.pop();
        } else break;
    }
}

generateMaze();

// === 繪製迷宮 ===
function drawMaze() {
    ctx.strokeStyle = "#89A7FF";
    ctx.lineWidth = 3;

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const cell = grid[r][c];
            const x = c * CELL;
            const y = r * CELL;

            ctx.beginPath();
            if (cell.walls.top) ctx.moveTo(x, y), ctx.lineTo(x + CELL, y);
            if (cell.walls.right) ctx.moveTo(x + CELL, y), ctx.lineTo(x + CELL, y + CELL);
            if (cell.walls.bottom) ctx.moveTo(x, y + CELL), ctx.lineTo(x + CELL, y + CELL);
            if (cell.walls.left) ctx.moveTo(x, y), ctx.lineTo(x, y + CELL);
            ctx.stroke();
        }
    }
}

// === 光照效果 ===
function drawLight() {
    // 先把整個畫布蓋成背景色（或透明，因為 body 已經是漸層）
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ===== 1. 先畫迷宮（黑色） =====
    ctx.strokeStyle = "#ffffff";   // 迷宮線條要讓光照到時顯示白色
    ctx.lineWidth = 4;
    drawMazeLines();               // ← 你原本用的迷宮線畫法

    // ===== 2. 設定光圈「白色」 =====
    const gradient = ctx.createRadialGradient(
        lightX, lightY, 0,        // 中心
        lightX, lightY, lightRadius  // 半徑
    );
    gradient.addColorStop(0, "rgba(255,255,255,1)");      // 中心最亮（白色）
    gradient.addColorStop(1, "rgba(255,255,255,0)");      // 外圍透明

    // ===== 3. 用「destination-in」讓只有光圈範圍的迷宮被留下 =====
    ctx.globalCompositeOperation = "destination-in";
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // ===== 4. 恢復模式 =====
    ctx.globalCompositeOperation = "source-over";
}

// === 終點光圈 ===
function checkGoal() {
    if (Math.hypot(lightX - finishX, lightY - finishY) < 40) {
        successEl.classList.add("show");
    }
}

// === 主程式 ===
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawMaze();
    drawLighting();
    checkGoal();

    requestAnimationFrame(draw);
}

draw();

// === 滑鼠移動 ===
canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    lightX = e.clientX - rect.left;
    lightY = e.clientY - rect.top;
});
</script>
</body>
</html>
